01042023 (CH-11: Processes and Signals):

Process is a program which is in execution state.
Each Process is allocated a unique number called PID(Process Identifier).

The Linux process table is like a data structure describing all the processes
that are currently loaded.

Commands:

ps command:

The "ps" command shows only the processes that maintain a connection with
the current terminal, a console or a pseudo-terminal.
The "ps -ef" command shows all the processes running in the system.
The "ps -ax" command shows the STAT of all the processes.
There is also another way to see processes "ps -lf"
Some Important Process status codes are:
R : Running
T : Stopped
Z : Defunct or Zombie 
N : Low priority task "nice", lower the nice value higher the priority
s : Process is a session leader
+ : Process is fore-ground
l : Process is multi-threaded
< : High priority task

The Operating system determines the priority of a process based on a "nice"
value which defaults to 0 and on the behavior of the program.

The Linux Scheduler decides which process it will allow to run 
based on priority.

Starting New Processes (system, pexec, fork):

system command:

The system function runs the command passed to it as a string and
waits for it to complete.

Requires library #include <stdlib.h>
int system (const char *string);


exec command:

An exec function replaces the current process with a new process specified 
by the path or file argument.
An exec function is used to "hand off" execution of a program to another.
The exec functions are more efficient than system because the original 
program will no longer be running after the new one is started.

Requires library #include <unistd.h>

execl("/bin/ps", "ps", "ax", 0); // assumes ps is in /bin/
execlp("ps", "ps", "ax", 0); // assumes /bin is in PATH
execle("/bin/ps", "ps", "ax", 0, ps_envp); // passes own environment

execv("/bin/ps", ps_argv);
execvp("ps", ps_argv);
execve("/bin/ps", ps_argv, ps_envp);

Passing an argument array
char *const ps_argv[] = {"ps", "ax", 0};

Passing an environment variable
char *const ps_envp[] = {"PATH:/bin:/usr/bin", "TERM=console", 0};

fork command:

To use processes to perform morethan one function at a time, we can use either
threads or create an entirely separate process from within a program, 
as init does, rather than replace the current thread of execution as in case
of exec.
We can create a new process by calling fork. This sytem call duplicates the
current process, creating a new entry in the process table with many of the same
attributes as the current process.

#include <sys/types.h>
#include <unistd.h>
pid_t fork(void)

The call to fork returns new PID of the child process and the new process 
continues to execute just like the original, with the exception that in 
the child process the call to fork returns 0.

If the parent process finishes ahead of child, we may get a messy output,
so to overcome this we need to use a command called wait.

wait command:

The wait system call causes a parent process to pause until one of its 
child processes is stopped.The call returns the PID of the child process.This
will normally be a child process that has terminated.The status information 
allows the parent process to determine the exit status of the child process,
that is the value returned by main or passed to exit.

#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *stat_loc);


zombie or defunct process:

This process is created if the child process is finished earlier than parent,
although no longer the child process still remians in the system because the 
child will have an association with its parent, hence unless and until 
the parent process either terminates normally or calls for wait, this 
child process will stay there as a zombie or defunct process.
You need to always avoid zombie processes because they consume resources
until init cleans them up.

02042023 (CH-11: Processes and Signals):

A Signal is an event generated by linux system in response to some condition.
"raise" indicates the generation of a signal and "catch" indicates the receipt 
of a signal.

Signals are raised by some error conditions such as memory segment violations, 
floating-point processor errors or illegal instructions.
Signal names are defined by including the header file #include <signal.h>

FIRST GROUP OF SIGNALS:

SIGABRT : *Process abort
SIGALRM  :  Alarm Clock
SIGFPE   : *Floating-Point Exception
SIGHUP   :  Hangup
SIGILL   : *Illegal Instruction
SIGINT   :  Terminal Interrupt
SIGKILL  :  Kill (Can't be caught or ignored)
SIGPIPE  :  Write on a pipe with no reader
SIGQUIT  :  Terminal quit
SIGSEGV  : *Inavalid memory segment access
SIGTERM  :  Termination
SIGUSR1  :  User-defined signal1
SIGUSR2  :  User-defined signal2

If a process receives one of the above signals, without first arranging to
catch it, the process will be terminated immediately.Usually, a core dump file 
is created. This file called "core" is placed in the current directory is an 
image of the process that can be useful in debugging.

SECOND GROUP OF SIGNALS:

SIGCHLD  :  Child process has stopped or exited
SIGCONT  :  Continue executing, if stopped
SIGSTOP  :  Stop executing (Can't be caught or ignored)
SIGTSTP  :  Terminal stop signal
SIGTTIN  :  Background process trying to read 
SIGTTOU  :  Background process trying to write

SIGCHLD is useful for managing child processes and it's ignored by default.
These above group of signals are used by shell programs for job control
and are rarely used by user programs.

kill -l : It is used to list down all the signal commands

Basic understanding of signal :

If the shell and terminal driver are configured normally, typing the
interrupt character(normally CTRL + C) at the keyboard will result in the SIGINT 
signal being sent to the foreground process, that is, program currently running.
This will cause the program to terminate unless it has arranged to catch the 
signal.

Programs can handle signals using the signal library function.
#include <signal.h>
void ( *signal(int sig, void (*func) (int))) (int);

From the above lines, It can be understood that signal is a function that takes 
two arguments "sig" and "func".
The signal to be caught or ignored is given in the form of argument "sig" 
and the function to be called when the specified signal is received is given
in the form of "func".This function must be one that takes a single int 
argument(the signal received) and is of type void.
The signal function itself returns a function of same type which is the previous 
value of the function setup to handle this signal, or one of these two 
following signals:
SIG_IGN  :  Ignore the signal
SIG_DFL  :  Restore default behavior

SENDING SIGNALS:

A process may send a signal to another process, including itself,
by calling kill.
kill:
#include <sys/types.h>
#include <signal.h>
int kill (pid_t pid, int sig);

The Kill function sends the specified signal sig to the process whose identifier
is given by pid.
Signals also provide you with a useful alarm clock facility.The alarm function 
call can be used by a process to schedule a SIGALRM signal at sometime in
the future.

alarm:
#include <unistd.h>
unsigned int alarm(unsigned int seconds);
To see how alarm works, we can make use of fork, sleep and signal.

pause:
#include <unistd.h>
int pause(void);
This causes the program to suspend execution until a signal occurs.
When it receives a signal, any established handler is run and execution 
continues as normal.

ROBUST SIGNAL INTERFACE:
sigaction:
#include <signal.h>
int sigaction (int sig, const struct sigaction *act, struct sigaction *oact);

The sigaction structure, used to define the actions to be taken on receipt of
the signal specified by sig,is defined in signal.h and 
has at least the following members:
void (*) (int) sa_handler /* function, SIG_DFL or SIG_IGN
sigset_t sa_mask /* signals to block in sa_handler
int sa_flags /* signal action modifiers

The sigaction function sets the action associated with the signal sig. 
If oact is not null, sigaction writes the previous signal action to the 
location it refers to. If act is null, this is all sigaction does. If
act isn’t null, the action for the specified signal is set.

Within the sigaction structure pointed to by the argument act, 
sa_handler is a pointer to a function called when signal sig is received. 
This is much like the function func you saw earlier passed to signal.
You can use the special values SIG_IGN and SIG_DFL in the sa_handler field 
to indicate that the signal is to be ignored or the action is to be restored 
to its default, respectively.

The sa_mask field specifies a set of signals to be added to the process’s signal 
mask before the sa_handler function is called. These are the set of signals 
that are blocked and won’t be delivered to the process. This prevents the case 
you saw earlier where a signal is received before its handler has run to completion. 
Using the sa_mask field can eliminate this race condition.

Signal Sets:

The header file signal.h defines the type sigset_t and functions used to 
manipulate sets of signals.These sets are used in sigaction and other functions
to modify the process behavior on receipt of signals.

#include <signal.h>
int sigaddset(sigset_t *set, int signo);
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigdelset(sigset_t *set, int signo);
int sigismember(sigset_t *set, int signo);

int sigprocmask(int how, const sigset_t *set, sigset_t *oset);

sigprocmask can change the process signal mask in a number of ways according to
the how argument.New values for the signal mask are passed in the argument set
if it isn’t null, and the previous signal mask will be written to 
the signal set oset.

The how argument in sifprocmask can be any of the following ways:
SIG_BLOCK    : The signals in set are added to the signal mask
SIG_SETMASK  : The signal mask is set from set
SIG_UNBLOCK  : The signals in set are removed from the signal mask

If the set argument is a null pointer, the value of how is not used and
the only purpose of the call is to fetch the value of the 
current signal mask into oset.

int sigpending(sigset_t *set);
If a signal is blocked by a process, it won’t be delivered, but will remain 
pending. A program can determine which of its blocked signals are pending 
by calling the function sigpending.

int sigsuspend(const sigset_t *sigmask);
A process can suspend execution until the delivery of one of a set of signals 
by calling sigsuspend. This is a more general form of the pause function 
you met earlier.


SIGACTION FLAGS:
The sa_flags field of the sigaction structure used in sigaction may contain 
the values shown in the following table to modify signal behavior:

SA_NOCLDSTOP   :  Don't generate SIGCHLD when child processes stop
SA_RESETHAND   :  Reset signal action to SIG_DFL on receipt
SA_RESTART     :  Restart interruptible functions rather than error with EINTR
SA_NODEFER     :  Don't add the signal to the signal mask when caught


03042023 (CH11: Processes and Signals):

Review of chapter-11.
Practicing process commands by customizing them and calling new processes from 
within a process.(system, exec and its types).
Attended Link2k developer guide session.
execl_1.c: executing pstree command.
execlp_1.c: executing ifconfig command.
execlp_2.c: executing ps -l or ps -ef commands.
execle_1.c: executing dmesg command.
execv_1.c: executing ifconfig or ls or top commands.
execvp_1.c: executing ifconfig command.
execve_1.c: executing man grep command.

Note that in general exec functions don't return unless an error occurs, in 
which case the error variable errno is set and the exec function returns -1.

04042023 (CH11: Processes and Signals):

Summary: 
Till now we have seen three important process commands:
"ps", "system" and "exec".

"system" is a useful utility but has a drawback that unless a process running is 
completed, we cannot run any other task.

But "exec" is a more efficient way of running a process, as the first process 
is handed over or taken over by new process.
And we have also seen 6 types of exec variations in the way file paths 
and arguments are passed.


To make it more efficient by allowing to perform more than one function 
at a time, we can either use threads or create an entirely separate process
from within a program as init does, rather than replace the current thread of 
execution, as in the exec case.

This can be achieved by calling "fork".This "fork" call duplicates the current 
process creating a new entry in the process table with many of the same 
attributes as the current process.

Praticing and understanding of fork, wait and signal handling.

05042023 (CH11: Processes and Signals):

Practicing of linux commands and vi editor

06042023(CH11: Processes and Signals)

Practicing of linux commands and vi editor.
Understanding Processes and Signals.

07042023(CH11: Processes and Signals)

All about signals:

A Signal is an even generated by linux systems in response to some 
condition, upon receipt of which a process may in turn take some action.

Signals are raised by some error conditions such as:
memory segment violations
floating-point processor errors
illegal instructions

#include <signal.h>
void (*signal(int sig, void (*func) (int))) (int);

This rather complex declaration says that signal is a function that takes 
two parameters, sig and func.
The signal to be caught or ignored is given as argument sig.
The function to be called when the specified
signal is received is given as func.


10042023(CH12: POSIX THREADS)

POSIX : Portable Operating System Interface

Multiple strands of execution in a single program are called threads.
In general, switching between threads requires the operating system to do
much less work than switching between processes.

And Threads are much less demanding on resources than multiple processes.
But design difficulties of writing a multi-threaded program are significant 
and cannot be taken lightly.

#include <pthread.h>

int pthread_create(pthread_t *thread, pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);

Using fork causes execution to continue in the same location with a different 
return code, whereas using a new thread explicitly provides a pointer(a new
location)to a function where the new thread should start executing.

When a thread terminates, it calls the pthread_exit function, much as a process
calls exit when it terminates.
Note that never return a pointer to a variable instead of returning a pointer 
to an object.

#include <pthread.h>

void pthread_exit(void *retval);

pthread_join is the thread equivalent to "wait" that processes use to collect 
child processes.

#include <pthread.h>
int pthread_join(pthread_t th, void **thread_return);

The first parameter is the thread for which to wait, the identifier that
pthread_create filled in for you.
The second argument is a pointer to a pointer that itself points to the return
value from the thread.

Like pthread_create, this pthread_join returns zero for success and an 
error code on failure.

11042023(Revision)
Practice of 'C': Functions and Pointers

12042023(CH12: POSIX-THREADS)

Why Threads?

1) Switching between threads requires much less OS than Switching between Processes.

2) The overhead cost of creating a new thread is very low compared to creating
   a new process.
    
3) The performance of an application that mixes input, calculation and output
    may be improved by running these as three separate threads.
    
pthread_create creates a new thread much as fork creates a new process.

Using fork causes execution to continue in the same location with a different 
return code, whereas using a new thread explicitly provides a pointer to a function
where the new thread should start executing.

Comparison:
Processes <-----> Threads

fork <---------> pthread_create
exit <---------> pthread_exit
wait <---------> pthread_join

13042023(CH12-POSIX-Threads)

Simultaneous execution of two threads sharing a single global variable:

Each thread tells the other one to run by setting the "run_now" variable and 
then waits till the other thread has changed its value before running again.
This shows that execution passes between the two threads automatically and again
illustrates the point that both threads are sharing the run_now variable.

linux commands: cmp, diff, patch, man, help

Set of functions designed to provide better ways to control the execution
of threads and access to critical sections of code are "semaphore" and "mutexes".

Semaphore: It acts as a gate-keeper around a piece of code.
Mutexes : Acts as mutual exclusion device to protect sections of code.

Two types of interfaces:
1) POSIX Real time extensions for Threads.
2) SYSTEM V Semaphores (for process synchronization).

The purpose of semaphores is to protect a piece of code so that only one thread 
of execution can run at any one time(which can be done by Binary semaphore).

There is also another general semaphore, occassionaly when we want to permit
a limited number of threads to execute a given piece of code.(which normally 
can be done by a Counting Semaphore).

Semaphore functions start with "sem_"

Normally there are four basic semaphore functions used in threads.

A Semaphore is created with a "sem_init" function

#include <semaphore.h>
int sem_init(sem_t *sem, int pshared, unsigned int value);

The next pair of functions controls the value of semaphore and is discussed
as follows:

#include <semaphore.h>
int sem_post(sem_t *sem);
int sem_wait(sem_t *sem);
int sem_destroy(sem_t *sem);

14042023(CH12-POSIX-Threads)

Revision of Pointers and functions.
Writing thread programs.

17042023(CH12-POSIX-Threads)

Revision of Ch-11(Processes and signals)

18042023(CH12-POSIX-Threads)

Pointers and functions
CH-12:Thread Synchronization

19042023(CH12-POSIX-Threads)

Pointers and functions

20042023(CH12-POSIX-Threads)
Pointers practice

21042023(CH12-POSIX-Threads)
Thread Synchronization with semaphores

24042023(CH12-POSIX-Threads)
Writing Programs to understand Binary Semaphore.
Synchronization of Threads with Mutexes.

25042023(CH12-POSIX-Threads)
Comparison between semaphores and mutexes.

26042023(CH12-POSIX-Threads)
Understanding Multiple threads inside a process, where each thread shares file
scope variables.

27042023
Exploring SELinux and Networking concepts.

02052023(CH13-IPC:Pipes)
Reading output from an External Program with examples.
Sending output to popen.

03052023(CH13-IPC:Pipes)
04052023(CH13-IPC:Pipes)
05052023(CH13-IPC:Pipes)
08052023(Linux commands Revision and Networking document)
09052023(Linux commands Revision and Networking document)

15052023(CH13-IPC:Pipes)
16052023(CH13-IPC:Pipes)
17052023(CH13-IPC:Pipes)
18052023(CH13:IPC:Pipes)
19052023(CH13:IPC:Pipes)
22052023(CH13:IPC:Pipes)
23052023(CH13:IPC:Pipes)
24052023(CH13:IPC:Pipes)
25052023(CH13:IPC:Pipes)


















